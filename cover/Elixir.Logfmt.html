<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>cover/Elixir.Logfmt.html</title>
</head><body style='background-color: white; color: black'>
<pre>
File generated from /Users/clem/Projects/logfmt-elixir/lib/logfmt.ex by COVER 2015-05-31 at 21:08:19

****************************************************************************

        |  defmodule Logfmt do
        |    import String, only: [next_grapheme: 1]
        |  
        |    @doc ~S"""
        |    Parses the given line into a map
        |  
        |    ## Examples
        |  
        |        iex&gt; Logfmt.decode "foo=bar baz=qux"
        |        %{"foo" =&gt; "bar", "baz" =&gt; "qux"}
        |  
        |        iex&gt; Logfmt.decode ~s(foo="bar baz")
        |        %{"foo" =&gt; "bar baz"}
        |  
        |        iex&gt; Logfmt.decode "foo=true"
        |        %{"foo" =&gt; true}
        |  
        |        iex&gt; Logfmt.decode "foo=1"
        |        %{"foo" =&gt; 1}
        |    """
        |    @spec decode(String.t) :: map
        |    def decode(string) do
    24..|      parse_char(next_grapheme(string), :garbage, %{})
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, map) :: map
        |    defp parse_char({char, rest}, :garbage, map)
        |    when char &gt; " " and char != "\"" and char != "=" do
    26..|      parse_char(next_grapheme(rest), :key, char, map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, map) :: map
        |    defp parse_char({_char, rest}, :garbage, map) do
     1..|      parse_char(next_grapheme(rest), :garbage, map)
        |    end
        |  
        |    @spec parse_char(nil, atom, map) :: map
        |    defp parse_char(nil, :garbage, map) do
     8..|      map
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, map) :: map
        |    defp parse_char({char, rest}, :key, key, map)
        |    when char &gt; " " and char != "\"" and char != "=" do
    52..|      parse_char(next_grapheme(rest), :key, key &lt;&gt; char, map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, map) :: map
        |    defp parse_char({"=", rest}, :key, key, map) do
    24..|      parse_char(next_grapheme(rest), :equals, key, map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, map) :: map
        |    defp parse_char({_char, rest}, :key, key, map) do
     1..|      parse_char(next_grapheme(rest), :garbage, map |&gt; put_value(key, true))
        |    end
        |  
        |    @spec parse_char(nil, atom, String.t, map) :: map
        |    defp parse_char(nil, :key, key, map) do
     1..|      map |&gt; put_value(key, true)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, map) :: map
        |    defp parse_char({char, rest}, :equals, key, map)
        |    when char &gt; " " and char != "\"" and char != "=" do
    17..|      parse_char(next_grapheme(rest), :ivalue, key, char, map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, map) :: map
        |    defp parse_char({"\"", rest}, :equals, key, map) do
     5..|      parse_char(next_grapheme(rest), :qvalue, false, key, "", map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, map) :: map
        |    defp parse_char({_char, rest}, :equals, key, map) do
     1..|      parse_char(next_grapheme(rest), :garbage, map |&gt; put_value(key, true))
        |    end
        |  
        |    @spec parse_char(nil, atom, String.t, map) :: map
        |    defp parse_char(nil, :equals, key, map) do
     1..|      map |&gt; put_value(key, true)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, String.t, map) :: map
        |    defp parse_char({char, rest}, :ivalue, key, value, map)
        |    when char &lt;= " " or char == "\"" or char == "=" do
     4..|      parse_char(next_grapheme(rest), :garbage, map |&gt; put_value(key, value))
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, String.t, String.t, map) :: map
        |    defp parse_char({char, rest}, :ivalue, key, value, map) do
    34..|      parse_char(next_grapheme(rest), :ivalue, key, value &lt;&gt; char, map)
        |    end
        |  
        |    @spec parse_char(nil, atom, String.t, String.t, map) :: map
        |    defp parse_char(nil, :ivalue, key, value, map) do
    13..|      map |&gt; put_value(key, value)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, boolean, String.t, String.t, map) :: map
        |    defp parse_char({"\\", rest}, :qvalue, false, key, value, map) do
     1..|      parse_char(next_grapheme(rest), :qvalue, true, key, value, map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, boolean, String.t, String.t, map) :: map
        |    defp parse_char({char, rest}, :qvalue, true, key, value, map) do
     1..|      parse_char(next_grapheme(rest), :qvalue, false, key, value &lt;&gt; char, map)
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, boolean, String.t, String.t, map) :: map
        |    defp parse_char({"\"", rest}, :qvalue, false, key, value, map) do
     4..|      parse_char(next_grapheme(rest), :garbage, map |&gt; put_value(key, value))
        |    end
        |  
        |    @spec parse_char({String.t, String.t}, atom, boolean, String.t, String.t, map) :: map
        |    defp parse_char({char, rest}, :qvalue, false, key, value, map) do
    27..|      parse_char(next_grapheme(rest), :qvalue, false, key, value &lt;&gt; char, map)
        |    end
        |  
        |    @spec parse_char(nil, atom, boolean, String.t, String.t, map) :: map
        |    defp parse_char(nil, :qvalue, false, key, value, map) do
     1..|      map |&gt; put_value(key, value)
        |    end
        |  
        |    @spec put_value(map, String.t, boolean) :: map
        |    defp put_value(map, key, value) when is_boolean(value) do
     4..|      map |&gt; Map.put(key, value)
        |    end
        |  
        |    @spec put_value(map, String.t, String.t) :: map
        |    defp put_value(map, key, value) do
    22..|      map |&gt; Map.put(key, value |&gt; cast)
        |    end
        |  
        |    @spec cast(String.t) :: boolean
        |    defp cast("true"), do: true
        |  
        |    @spec cast(String.t) :: boolean
        |    defp cast("false"), do: false
        |  
        |    @spec cast(String.t) :: Float | Integer | String.t
        |    defp cast(value)  do
    19..|      integer = case Integer.parse(value) do
     4..|        {integer, ""} -&gt; integer
        |        {_, _}        -&gt; nil
        |        :error        -&gt; nil
        |      end
        |  
    19..|      float = case Float.parse(value) do
     7..|        {float, ""} -&gt; float
        |        {_, _}      -&gt; nil
        |        :error      -&gt; nil
        |      end
        |  
    19..|      integer || float || value
        |    end
        |  end
</pre>
</body>
</html>
